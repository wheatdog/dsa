%
% Homework Details
%   - Title
%   - Due date
%   - University
%   - Class
%   - Class Alias
%   - Class Section
%   - Instructor
%   - Author
%   - AuthorID
%

\newcommand{\hmwkID}{5}
\newcommand{\hmwkTitle}{Homework\ \#\hmwkID}
\newcommand{\hmwkDueDate}{May 26, 2015 at 16:20}
\newcommand{\hmwkUniversity}{NTU}
\newcommand{\hmwkClass}{Data Structures and Algorithms}
\newcommand{\hmwkClassAlias}{DSA}
\newcommand{\hmwkClassSection}{Spring 2015}
\newcommand{\hmwkClassInstructor}{Hsuan-Tien Lin, Roger Jang}
\newcommand{\hmwkAuthorName}{Tim Liou}
\newcommand{\hmwkAuthorID}{b03902028}


\input{../../dep/dsa-hw-template.tex}

\usepackage{qtree}

\begin{document}

\pagenumbering{gobble}

\maketitle

\pagebreak

\pagenumbering{arabic}  

\begin{homeworkProblem}{Heap and Hash}
    \subqest{Complete Exercise R-8.24 of the textbook.}
    Consider a min heap. The insertion of an entry with key 32 would cause up-head
    bubbling to proceed all the way up to a child of the root in this heap.

    \Tree [.1 [.3 [.5 [.9 17 19 ] [.11 21 23 ] ] [.7 [.13 25 27 ] [.15 29 31 ] ] ] [.33 [.47 [.55 57 59 ] [.49 53 51 ] ] [.35 [.41 45 43 ] [.37 39 (32) ] ] ] ]

    \subqest{Complete Exercise C-8.4 of the textbook.}
    Combine each key we want to insert to the stack with a priority variable.
    These combinations would be insert to the MaxPriorityQueue which compare
    elements by the priority variable. Note that the basic idea of this method
    is the fact that every new element is pushed in stack with a priority higher
    than the current one. Then, MaxPriorityQueue will behave in the LIFO way, 
    which is what we want.

    \begin{lstlisting}[breaklines=true]
    class Stack {
        class Element { int priority, Key element; };
        MaxPriorityQueue<Element> MaxPQ;
        int top_priority = 0;

        void push(Key key) { MaxPQ.insert(Element(top_priority++, key)); }
        void pop() { top_priority--; MaxPQ.removeMax() }
        const Key& top() { return MaxPQ.max(); }
        int size() { return top_priority; }
        bool empty() { return (top_priority == 0); }
    };
    \end{lstlisting}

    \pagebreak

    \subqest{Complete Exercise C-8.14 of the textbook.}

    \begin{algorithm}[]
        \begin{algorithmic}[1]
            \Function{FindLeqElemInHeap}{\emph{heap, key}}
            \While{heap.top() $\leq$ key}
                \State{insert heap.top() into the output list, and do heap.removeMin()}
            \EndWhile
            \State{\Return the output list}
            \EndFunction{}
        \end{algorithmic}
        \caption{Compute all the entries in a heap with a key less than or equal to the value}
    \end{algorithm}

    \subqest{Hash function is everywhere. Use any search engine to study the 
        term “MinHash” Explain to the TAs what it is and why it is useful. Also,
        cite the website that you learn the term from.}
    \pending

    \subqest{Describe an algorithm to find out the position that the two strings
        differ efficiently. Briefly discuss and justify the time complexity of
        your algorithm.}
    \pending

    \subqest{Construct a perfect hash function that is efficiently computable
            for the following 32 standard keywords in C. You need to explain why
            the hash function is perfect and why it is efficiently computable to
            get the full bonus.}
    \pending

\end{homeworkProblem}

\begin{homeworkProblem}{Distributed System}
    \subqest{Finish/rewrite the BinomialHeap class, and describe how you test 
        whether the data structure is correct.}
    \pending

    \subqest{Implement the system for three kinds of commands below.}
    \pending[code part]


\end{homeworkProblem}
\end{document}
